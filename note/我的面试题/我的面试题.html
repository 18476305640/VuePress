<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>我的面试题 | 肥小猪</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="肥小猪的笔记">
    <meta name="author" content="zhuangjie">
    <meta name="keywords" content="小庄的博客 小庄的笔记 zhuangjie 庄杰">
    
    <link rel="preload" href="/assets/css/0.styles.83bfd168.css" as="style"><link rel="preload" href="/assets/js/app.5c666aae.js" as="script"><link rel="preload" href="/assets/js/2.f4acce4e.js" as="script"><link rel="preload" href="/assets/js/51.59e6212e.js" as="script"><link rel="prefetch" href="/assets/js/10.7d647c34.js"><link rel="prefetch" href="/assets/js/11.ea5229fb.js"><link rel="prefetch" href="/assets/js/12.b859755e.js"><link rel="prefetch" href="/assets/js/13.94d3b5a2.js"><link rel="prefetch" href="/assets/js/14.ed2f4480.js"><link rel="prefetch" href="/assets/js/15.b3e305e6.js"><link rel="prefetch" href="/assets/js/16.49f8a835.js"><link rel="prefetch" href="/assets/js/17.f4b4e831.js"><link rel="prefetch" href="/assets/js/18.582de590.js"><link rel="prefetch" href="/assets/js/19.c85bd795.js"><link rel="prefetch" href="/assets/js/20.92741434.js"><link rel="prefetch" href="/assets/js/21.b7c8497e.js"><link rel="prefetch" href="/assets/js/22.96b46a67.js"><link rel="prefetch" href="/assets/js/23.0bc030ab.js"><link rel="prefetch" href="/assets/js/24.87f04d87.js"><link rel="prefetch" href="/assets/js/25.0f54baf2.js"><link rel="prefetch" href="/assets/js/26.1c39a9d2.js"><link rel="prefetch" href="/assets/js/27.31d22914.js"><link rel="prefetch" href="/assets/js/28.fc7f7405.js"><link rel="prefetch" href="/assets/js/29.1e94a8cc.js"><link rel="prefetch" href="/assets/js/3.c8d9910f.js"><link rel="prefetch" href="/assets/js/30.61082fbd.js"><link rel="prefetch" href="/assets/js/31.9e80c088.js"><link rel="prefetch" href="/assets/js/32.8ef6a48c.js"><link rel="prefetch" href="/assets/js/33.3349c1af.js"><link rel="prefetch" href="/assets/js/34.14ace618.js"><link rel="prefetch" href="/assets/js/35.3dca7364.js"><link rel="prefetch" href="/assets/js/36.25d01ad8.js"><link rel="prefetch" href="/assets/js/37.4527c97e.js"><link rel="prefetch" href="/assets/js/38.30b3c9ab.js"><link rel="prefetch" href="/assets/js/39.6f6d8c82.js"><link rel="prefetch" href="/assets/js/4.c72729ae.js"><link rel="prefetch" href="/assets/js/40.6454dbfd.js"><link rel="prefetch" href="/assets/js/41.ba49a8db.js"><link rel="prefetch" href="/assets/js/42.2ec3f8ee.js"><link rel="prefetch" href="/assets/js/43.e40c89c6.js"><link rel="prefetch" href="/assets/js/44.3d45a7aa.js"><link rel="prefetch" href="/assets/js/45.2375de76.js"><link rel="prefetch" href="/assets/js/46.a4cfa405.js"><link rel="prefetch" href="/assets/js/47.ab954289.js"><link rel="prefetch" href="/assets/js/48.4b72016d.js"><link rel="prefetch" href="/assets/js/49.9d06f5f2.js"><link rel="prefetch" href="/assets/js/5.44547aad.js"><link rel="prefetch" href="/assets/js/50.8dc92268.js"><link rel="prefetch" href="/assets/js/52.adecc9a3.js"><link rel="prefetch" href="/assets/js/53.030d635f.js"><link rel="prefetch" href="/assets/js/54.52060cbc.js"><link rel="prefetch" href="/assets/js/6.18c29f84.js"><link rel="prefetch" href="/assets/js/7.6427b380.js"><link rel="prefetch" href="/assets/js/8.67154bc3.js"><link rel="prefetch" href="/assets/js/9.757fe49c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.83bfd168.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.png" alt="肥小猪" class="logo"> <span class="site-name can-hide">肥小猪</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/程序员的自身修养.html" class="nav-link">
  总览
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/程序员的自身修养.html" class="nav-link">
  总览
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>我的面试题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#目录" class="sidebar-link">目录</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_1-0-spring" class="sidebar-link">1.0 spring</a></li><li class="sidebar-sub-header"><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_2-0-springmvc" class="sidebar-link">2.0 springmvc</a></li><li class="sidebar-sub-header"><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-0-springboot面试题" class="sidebar-link">3.0 Springboot面试题</a></li><li class="sidebar-sub-header"><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_3-0-java面试题" class="sidebar-link">3.0 java面试题</a></li><li class="sidebar-sub-header"><a href="/note/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98.html#_4-0-mq面试题" class="sidebar-link">4.0 MQ面试题</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="我的面试题"><a href="#我的面试题" class="header-anchor">#</a> 我的面试题</h1> <h2 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h2> <p>别人的面试经：</p> <p><a href="https://juejin.cn/post/6844904125709156359" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904125709156359<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_1-0-spring"><a href="#_1-0-spring" class="header-anchor">#</a> 1.0 spring</h3> <h3 id="_2-0-springmvc"><a href="#_2-0-springmvc" class="header-anchor">#</a> 2.0 springmvc</h3> <h4 id="_2-1-什么是mvc模式"><a href="#_2-1-什么是mvc模式" class="header-anchor">#</a> 2.1 什么是MVC模式？</h4> <p>答：是模型-视图-控制器的简称，是一种软件设计的典范。它是用业务逻辑、数据与界面显示分离方法来组织代码。</p> <p>M是模型、V是视图、C是控制器。</p> <h4 id="_2-2-springmvc的执行流程"><a href="#_2-2-springmvc的执行流程" class="header-anchor">#</a> 2.2 SpringMVC的执行流程？</h4> <p>1.用户发送请求至前端控制器DispatcherServlet</p> <p>2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。</p> <p>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet（此时处理器映射器返回的处理器对象包含：包名+类名+方法名）。</p> <p>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p> <p>5.处理器适配器HandlerAdapter将会根据适配的结果去执行Handler。</p> <p>6.Handler执行完成返回ModelAndView。</p> <p>7.HandlerAdapter将Handler执行结果ModelAndView返回到前端控制器DispatcherServlet</p> <p>8.前端控制器DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p> <p>9.视图解析器ViewReslover解析后返回具体View</p> <p>10.前端控制器DispatcherServlet对View进行渲染视图。</p> <p>11.前端控制器DispatcherServlet向用户响应结果。 </p> <h4 id="_2-3-springmvc有哪些优点"><a href="#_2-3-springmvc有哪些优点" class="header-anchor">#</a> 2.3 SpringMVC有哪些优点？</h4> <ol><li><p>SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。</p></li> <li><p>SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。</p></li> <li><p>支持灵活的URL到页面控制器的映射。</p></li> <li><p>可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。</p></li> <li><p>拥有十分简洁的异常处理机制。</p></li> <li><p>可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。</p></li> <li><p>支持RestFul风格。</p></li></ol> <h4 id="_2-4-spingmvc主要组件"><a href="#_2-4-spingmvc主要组件" class="header-anchor">#</a> 2.4 SpingMVC主要组件</h4> <p>前端控制器：接收前端请求，然后给用户反馈</p> <p>处理器映射器：收集处理器</p> <p>处理器适配器：执行处理器</p> <p>视图解析器：根据ModelAndView返回具体的视图</p> <p>视图：是一个接口</p> <p>处理器：是请求的处理逻辑，返回相应的数据和视图信息，并封装到ModelAndView中</p> <h4 id="_2-5-springmvc和struts2的区别有哪些"><a href="#_2-5-springmvc和struts2的区别有哪些" class="header-anchor">#</a> 2.5 SpringMVC和Struts2的区别有哪些?</h4> <p>入口不同、url的映射关系不同、</p> <h4 id="_2-6-springmvc怎么样设定重定向和请求转发"><a href="#_2-6-springmvc怎么样设定重定向和请求转发" class="header-anchor">#</a> 2.6 SpringMVC怎么样设定重定向和请求转发？</h4> <p>都是通过返回一个String</p> <p>重定向： &quot;redirect:页面&quot;</p> <p>转发：&quot;forward:页面&quot;</p> <h4 id="_2-7怎么样把modelmap里面的数据放入session里面"><a href="#_2-7怎么样把modelmap里面的数据放入session里面" class="header-anchor">#</a> 2.7怎么样把ModelMap里面的数据放入session里面？</h4> <p>使用@SessionAttributes 注解</p> <h4 id="_2-8-dodispatcher的执行流程"><a href="#_2-8-dodispatcher的执行流程" class="header-anchor">#</a> 2.8 doDispatcher的执行流程</h4> <p>（1）调用mappedHandler = this.getHandler(processedRequest);  获取能够处理当前请求的执行链 HandlerExecutionChain （handler+拦截器）。</p> <p>如何获取handler的？会遍历handlerMappings数组，对应的是不同的Mapper对象。</p> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518867643421651886763638.png" alt=""></p> <p>（2）HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); 从执行链中获取handler调用getHandlerAdapter方法获取 HandlerAdapter 。</p> <p>如何获取的handlerAdapter？会遍历handlerAdapters数组，对应的是不同的adapter对象。</p> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518930253451651893025237.png" alt=""></p> <p>（3）mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 调用HandlerAdapter 的handle方法去执行那个handler得到ModelAndView。</p> <p>（4）this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 调用processDispatchResult方法结合mv完成视图渲染与跳转。</p> <h4 id="_2-9九大组件"><a href="#_2-9九大组件" class="header-anchor">#</a> 2.9九大组件 </h4> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token comment">//多部件解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">MultipartResolver</span> multipartResolver<span class="token punctuation">;</span>
    <span class="token comment">//国际化解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">LocaleResolver</span> localeResolver<span class="token punctuation">;</span>
    <span class="token comment">//主题解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">ThemeResolver</span> themeResolver<span class="token punctuation">;</span>
    <span class="token comment">//处理器映射器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerMapping</span><span class="token punctuation">&gt;</span></span> handlerMappings<span class="token punctuation">;</span>
    <span class="token comment">//处理器适配器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">&gt;</span></span> handlerAdapters<span class="token punctuation">;</span>
    <span class="token comment">//异常解析器组件</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerExceptionResolver</span><span class="token punctuation">&gt;</span></span> handlerExceptionResolvers<span class="token punctuation">;</span>
    <span class="token comment">//默认视图名转换器组件 </span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">RequestToViewNameTranslator</span> viewNameTranslator<span class="token punctuation">;</span>
    <span class="token comment">//flash属性管理组件</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">FlashMapManager</span> flashMapManager<span class="token punctuation">;</span>
    <span class="token comment">//视图解析器</span>
    <span class="token annotation punctuation">@Nullable</span>
    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ViewResolver</span><span class="token punctuation">&gt;</span></span> viewResolvers<span class="token punctuation">;</span>
</code></pre></div><h4 id="_3-0组件的初始化"><a href="#_3-0组件的初始化" class="header-anchor">#</a> 3.0组件的初始化</h4> <p>tomcat启动后，会有事件触发DisplayServlet调用onRefresh 方法，然后进行调用方法进行初始化。</p> <h4 id="_3-1-springmvc主要组件-五大组件"><a href="#_3-1-springmvc主要组件-五大组件" class="header-anchor">#</a> 3.1 SpringMVC主要组件（五大组件）；*
</h4> <p>DispatcherServlet：前端控制器，用于请求到达前端控制器，由它调用其他组件处理用户的请求。</p> <p>HandlerMapping：处理器映射器，负责根据用户请求找到Handler(处理器)，springmvc提供了不同的映射器实现方式。</p> <p>Handler：后端控制器（处理器），对具体的用户请求进行处理。</p> <p>HandlerAdapter：处理器适配器，通过HandlerAdapter对处理器进行执行。</p> <p>View Resolver：视图解析器，负责将处理结果生成view视图。 </p> <h4 id="_3-2-springmvc有哪些注解"><a href="#_3-2-springmvc有哪些注解" class="header-anchor">#</a> 3.2 SpringMVC有哪些注解</h4> <p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。</p> <p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。</p> <p>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p> <p>@Resource和@Autowired：@Resource和@Autowired都是做bean的注入时使用，其实            @Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p> <p>@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数</p> <h4 id="_3-3-springmvc怎么样设定重定向和转发的"><a href="#_3-3-springmvc怎么样设定重定向和转发的" class="header-anchor">#</a> 3.3 SpringMVC怎么样设定重定向和转发的？</h4> <p>1、转发：在返回值前面加&quot;forward:&quot;，譬如&quot;forward:user.do?name=method4&quot;</p> <p>2、重定向：在返回值前面加&quot;redirect:&quot;，譬如&quot;redirect:<a href="http://www.baidu.com" title="http://www.baidu.com" target="_blank" rel="noopener noreferrer">http://www.baidu.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>&quot;可能会问转发与重定向的区别。 </p> <h4 id="_3-4-spring事务传播机制是什么"><a href="#_3-4-spring事务传播机制是什么" class="header-anchor">#</a> 3.4 Spring事务传播机制是什么；
</h4> <p>Spring事务定义了7种传播机制：</p> <p>1、PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事 务，若不存在事务，则新建一个事务。</p> <p>2、PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。</p> <p>3、PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于REQUIRE_NEW。</p> <p>4、PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。</p> <p>5、PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂起。</p> <p>6、PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常。</p> <p>7、PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。</p> <h3 id="_3-0-springboot面试题"><a href="#_3-0-springboot面试题" class="header-anchor">#</a> 3.0 Springboot面试题</h3> <h4 id="什么是-spring-boot"><a href="#什么是-spring-boot" class="header-anchor">#</a> 什么是 Spring Boot？</h4> <ul><li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li></ul> <h4 id="为什么要用springboot"><a href="#为什么要用springboot" class="header-anchor">#</a> 为什么要用SpringBoot</h4> <ul><li>快速开发，快速整合，配置简化、内嵌服务容器</li></ul> <h4 id="springboot与springcloud-区别"><a href="#springboot与springcloud-区别" class="header-anchor">#</a> SpringBoot与SpringCloud 区别</h4> <ul><li>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</li></ul> <h4 id="spring-boot-有哪些优点"><a href="#spring-boot-有哪些优点" class="header-anchor">#</a> Spring Boot 有哪些优点？</h4> <ul><li><p>Spring Boot 主要有如下优点：</p> <ol><li><p>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</p></li> <li><p>开箱即用，远离繁琐的配置。</p></li> <li><p>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</p></li> <li><p>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</p></li></ol></li></ul> <h4 id="spring-boot-的核心注解是哪个-它主要由哪几个注解组成的"><a href="#spring-boot-的核心注解是哪个-它主要由哪几个注解组成的" class="header-anchor">#</a> Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h4> <ul><li><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p> <ul><li><p>@SpringBootConfiguration：组合了 @Configuration 注解，标注一个类为配置类，该类下的方法如果有@Bean, 那么会以方法名作为Bean的名字，返回值作为Bean的类型注入到Spring容器中。</p></li> <li><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：<code>java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</code></p></li> <li><p>@ComponentScan：Spring组件扫描。会扫描该类包下的所有配置类</p></li></ul></li></ul> <h4 id="springboot-starter的工作原理"><a href="#springboot-starter的工作原理" class="header-anchor">#</a> SpringBoot Starter的工作原理</h4> <ul><li><p><code>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</code></p></li> <li><p>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</p></li></ul> <h3 id="_3-0-java面试题"><a href="#_3-0-java面试题" class="header-anchor">#</a> 3.0 java面试题</h3> <h4 id="_3-1-说一下-封装、继承、多态"><a href="#_3-1-说一下-封装、继承、多态" class="header-anchor">#</a> 3.1 说一下，封装、继承、多态</h4> <p>封装：把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。</p> <p>继承：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。</p> <p>多态：多态性是对象多种表现形式的体现。</p> <p>抽象：</p> <h4 id="_3-2-string、stringbuffer、stringbuilder三者之间的区别"><a href="#_3-2-string、stringbuffer、stringbuilder三者之间的区别" class="header-anchor">#</a> 3.2 String、StringBuffer、StringBuilder三者之间的区别</h4> <p><strong>String</strong> <strong>字符串常量</strong></p> <p><strong>StringBuffer 字符串变量（线程安全）</strong></p> <p><strong>StringBuilder 字符串变量（非线程安全）</strong></p> <h4 id="_3-3-string常用的方法"><a href="#_3-3-string常用的方法" class="header-anchor">#</a> 3.3 String常用的方法</h4> <p>返回指定字符的索引：indexOf()</p> <p>返回指定索引处的字符：charAt()</p> <p>字符串替换：replace()</p> <p>去除字符串两端空白：trim()</p> <p>分割字符串，返回一个分割后的字符串数组：split()</p> <p>返回字符串的 byte 类型数组：getBytes()</p> <p>返回字符串长度：length()</p> <p>将字符串转成小写字母：toLowerCase()</p> <p>将字符串转成大写字符：toUpperCase()</p> <p>截取字符串：substring()</p> <p>字符串比较：equals()</p> <h4 id="_3-4-反射"><a href="#_3-4-反射" class="header-anchor">#</a> 3.4 反射</h4> <h4 id="_3-5-jdb1-8的新特性"><a href="#_3-5-jdb1-8的新特性" class="header-anchor">#</a> 3.5 JDB1.8的新特性</h4> <p>1 Lambda 表达式</p> <p>2 方法引用 </p> <p>3 函数式接口</p> <p>4 接口允许定义默认方法和静态方法</p> <p>5 Stream API  </p> <p>6 日期/时间类改进 </p> <p>7 Optional 类</p> <p>8 Java8 Base64 实现 </p> <h4 id="_3-6-异常"><a href="#_3-6-异常" class="header-anchor">#</a> 3.6 异常</h4> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519929145191651992914201.png" alt=""></p> <h4 id="_3-7-jdk源码"><a href="#_3-7-jdk源码" class="header-anchor">#</a> 3.7 JDK源码</h4> <p>如果 HashMap</p> <h4 id="_3-8-java集合"><a href="#_3-8-java集合" class="header-anchor">#</a> 3.8 Java集合</h4> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519934905201651993485895.png" alt=""></p> <p>(1)Connection<strong>接口</strong>:<strong>List</strong> 有序,可重复</p> <p><strong>ArrayList</strong>  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程不安全，效率高 <strong>Vector</strong>  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程安全，效率低, 已给舍弃了 <strong>LinkedList</strong>  优点: 底层数据结构是链表，查询慢，增删快。  缺点: 线程不安全，效率高<strong>Set</strong> 无序,唯一</p> <p><strong>HashSet</strong>  底层数据结构是哈希表。(无序,唯一) 如何来保证元素唯一性? 依赖两个方法：hashCode()和equals()</p> <p><strong>LinkedHashSet</strong>  底层数据结构是链表和哈希表。(FIFO插入有序,唯一)  </p> <p>1.由链表保证元素有序 2.由哈希表保证元素唯一</p> <p><strong>TreeSet</strong>  底层数据结构是红黑树。(唯一，有序)  </p> <ol><li>如何保证元素排序的呢? 自然排序  比较器排序 2.如何保证元素唯一性的呢?  </li></ol> <p>根据比较的返回值是否是0来决定</p> <p><strong>(2)Map</strong>接口有四个实现类： </p> <p><strong>HashMap</strong>   基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键， 线程不安全。  <strong>HashTable</strong>   线程安全，低效，不支持 null 值和 null 键； <strong>LinkedHashMap</strong>   线程不安全，是 HashMap 的一个子类，保存了记录的插入顺序； <strong>TreeMap</strong></p> <p>能够把它保存的记录根据键排序，默认是键值的升序排序，线程不安全。</p> <h4 id="_3-9-hashmap"><a href="#_3-9-hashmap" class="header-anchor">#</a> 3.9 HashMap</h4> <p>底层：</p> <p>JDK1.8前是数组+链表</p> <p>JDK1.8后是数组+链表 或 数组+红黑树（当链表长度 ≥ 8 时，≤ 6 时退化为链表）。</p> <p>首次put时才会创建数组，长度为16，超过负载因子75%的容量时，乘于加载因子，会调用rehash方法使变为原来的两倍。</p> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519937367691651993736687.png" alt=""></p> <h4 id="_4-10-有符号与无符号"><a href="#_4-10-有符号与无符号" class="header-anchor">#</a> 4.10 有符号与无符号</h4> <p>看它的二进制的最高位，如果是1为负数，0为正数。</p> <h4 id="_4-11-原码、反码、补码"><a href="#_4-11-原码、反码、补码" class="header-anchor">#</a> 4.11 原码、反码、补码</h4> <p>原码：就当前的</p> <p>反码：符号位不变，其它按位取反。</p> <p>补码：反码+1</p> <p>特别地：0的反码、补码都是0 ； 正数的原码、反码、补码相同。</p> <p>注意：计算算在运算的时候，都是以补码的方式来运算的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">1</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>计算机运行
将<span class="token number">1</span> 与<span class="token operator">-</span><span class="token number">2</span>都转为补码，然后进行二进制的<span class="token operator">+</span>运算。再将结果由补码到原码（<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token parameter">反码</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token parameter">符号位除外取反</span> <span class="token operator">=&gt;</span> <span class="token parameter">原码</span> <span class="token operator">=&gt;</span> 十进制  ）
</code></pre></div><p>视频：<a href="https://www.bilibili.com/video/BV17y4y1275u" title="https://www.bilibili.com/video/BV17y4y1275u" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV17y4y1275u<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="_4-12"><a href="#_4-12" class="header-anchor">#</a> 4.12 &gt;&gt;  &gt;&gt;&gt;</h4> <p>对应右移和无符号右移</p> <p><img src="https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16520002231541652000222829.png" alt=""></p> <h4 id="_4-13-hashmap与hashtable-concurrenthashmap区别"><a href="#_4-13-hashmap与hashtable-concurrenthashmap区别" class="header-anchor">#</a> 4.13 HashMap与HashTable   ConcurrentHashMap区别</h4> <p>HashMap是线程不安全的，而HashTable与ConcurrentMap 都是线程安全的，只不过实现线程安全的方法不同。</p> <p>HashTable一般现在不建议用 HashTable, ①是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。</p> <p>HashTable 使用的是 Synchronized 关键字修饰，ConcurrentHashMap 是JDK1.7使用了锁分段技术来保证线程安全的。JDK1.8ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。</p> <h3 id="_4-0-mq面试题"><a href="#_4-0-mq面试题" class="header-anchor">#</a> 4.0 MQ面试题</h3> <h4 id="_4-1rabbitmq-上的一个-queue-中存放的-message-是否有数量限制"><a href="#_4-1rabbitmq-上的一个-queue-中存放的-message-是否有数量限制" class="header-anchor">#</a> 4.1RabbitMQ 上的⼀个 queue 中存放的 message 是否有数量限制？</h4> <p>可以认为是⽆限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。</p> <h4 id="_4-2-如何确保消息不丢失"><a href="#_4-2-如何确保消息不丢失" class="header-anchor">#</a> 4.2 如何确保消息不丢失？</h4> <p>将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会⾃动创建）。</p> <h4 id="_4-3如何确保消息正确地发送至rabbitmq"><a href="#_4-3如何确保消息正确地发送至rabbitmq" class="header-anchor">#</a> 4.3如何确保消息正确地发送⾄RabbitMQ？</h4> <p>将信道设置成confirm模式（发送⽅确认模式），则所有在信道上发布的消息都会被指派⼀个唯⼀的ID。⼀旦消息被投递到⽬的队列后，或者消息被写⼊磁盘后（可持久化的消息），信道会发送⼀个确认给⽣产者（包含消息唯⼀ID）。如果RabbitMQ发⽣内部错误从⽽导致消息丢失，会发送⼀条nack（not acknowledged，未确认）消息。</p> <h4 id="_4-4-如何确保消息接收方消费了消息"><a href="#_4-4-如何确保消息接收方消费了消息" class="header-anchor">#</a> 4.4 如何确保消息接收⽅消费了消息？</h4> <p><strong>接收⽅消息确认机制</strong>：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。</p> <h4 id="_4-5-如何避免消息重复投递或重复消费"><a href="#_4-5-如何避免消息重复投递或重复消费" class="header-anchor">#</a> 4.5 如何避免消息重复投递或重复消费？</h4> <p>使用消息的全局ID，在消费消息时判断之前是否已消费了该消息，如果消息就不再消费，从而避免重复消费。</p> <h4 id="_4-6-消息基于什么传输"><a href="#_4-6-消息基于什么传输" class="header-anchor">#</a> 4.6 消息基于什么传输？</h4> <p>RabbitMQ使⽤信道的⽅式来传输数据。信道是建⽴在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p> <h4 id="_4-7-queue队列"><a href="#_4-7-queue队列" class="header-anchor">#</a> 4.7 .Queue队列？</h4> <p>Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。</p> <h4 id="_4-8-exchange交换器"><a href="#_4-8-exchange交换器" class="header-anchor">#</a> 4.8.Exchange交换器？</h4> <p>Exchange:生产者将消息发送到交换器，有交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</p> <h4 id="_4-9-routingkey路由键"><a href="#_4-9-routingkey路由键" class="header-anchor">#</a> 4.9 RoutingKey路由键？</h4> <p>生产者将消息发送给交换器的时候，会指定一个RoutingKey,用来指定这个消息的路由规则，这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。</p> <h4 id="_4-10-交换机类型"><a href="#_4-10-交换机类型" class="header-anchor">#</a> 4.10  交换机类型</h4> <p>fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</p> <p>direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。</p> <p>topic:</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2022年12月30日星期五下午4点40分</span></div></footer> <!----> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.5c666aae.js" defer></script><script src="/assets/js/2.f4acce4e.js" defer></script><script src="/assets/js/51.59e6212e.js" defer></script>
  </body>
</html>
