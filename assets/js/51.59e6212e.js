(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{326:function(a,t,s){"use strict";s.r(t);var r=s(10),e=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"我的面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#我的面试题"}},[a._v("#")]),a._v(" 我的面试题")]),a._v(" "),t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[a._v("#")]),a._v(" 目录")]),a._v(" "),t("p",[a._v("别人的面试经：")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6844904125709156359",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://juejin.cn/post/6844904125709156359"),t("OutboundLink")],1)]),a._v(" "),t("h3",{attrs:{id:"_1-0-spring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-spring"}},[a._v("#")]),a._v(" 1.0 spring")]),a._v(" "),t("h3",{attrs:{id:"_2-0-springmvc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-springmvc"}},[a._v("#")]),a._v(" 2.0 springmvc")]),a._v(" "),t("h4",{attrs:{id:"_2-1-什么是mvc模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是mvc模式"}},[a._v("#")]),a._v(" 2.1 什么是MVC模式？")]),a._v(" "),t("p",[a._v("答：是模型-视图-控制器的简称，是一种软件设计的典范。它是用业务逻辑、数据与界面显示分离方法来组织代码。")]),a._v(" "),t("p",[a._v("M是模型、V是视图、C是控制器。")]),a._v(" "),t("h4",{attrs:{id:"_2-2-springmvc的执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-springmvc的执行流程"}},[a._v("#")]),a._v(" 2.2 SpringMVC的执行流程？")]),a._v(" "),t("p",[a._v("1.用户发送请求至前端控制器DispatcherServlet")]),a._v(" "),t("p",[a._v("2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。")]),a._v(" "),t("p",[a._v("3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet（此时处理器映射器返回的处理器对象包含：包名+类名+方法名）。")]),a._v(" "),t("p",[a._v("4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器")]),a._v(" "),t("p",[a._v("5.处理器适配器HandlerAdapter将会根据适配的结果去执行Handler。")]),a._v(" "),t("p",[a._v("6.Handler执行完成返回ModelAndView。")]),a._v(" "),t("p",[a._v("7.HandlerAdapter将Handler执行结果ModelAndView返回到前端控制器DispatcherServlet")]),a._v(" "),t("p",[a._v("8.前端控制器DispatcherServlet将ModelAndView传给ViewReslover视图解析器。")]),a._v(" "),t("p",[a._v("9.视图解析器ViewReslover解析后返回具体View")]),a._v(" "),t("p",[a._v("10.前端控制器DispatcherServlet对View进行渲染视图。")]),a._v(" "),t("p",[a._v("11.前端控制器DispatcherServlet向用户响应结果。 ")]),a._v(" "),t("h4",{attrs:{id:"_2-3-springmvc有哪些优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-springmvc有哪些优点"}},[a._v("#")]),a._v(" 2.3 SpringMVC有哪些优点？")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("SpringMVC本身是与Spring框架结合而成的，它同时拥有Spring的优点(例如依赖注入DI和切面编程AOP等)。")])]),a._v(" "),t("li",[t("p",[a._v("SpringMVc提供强大的约定大于配置的契约式编程支持，即提供一种软件设计范式，减少软件开发人员做决定的次数，开发人员仅需规定应用中不符合约定的部分。")])]),a._v(" "),t("li",[t("p",[a._v("支持灵活的URL到页面控制器的映射。")])]),a._v(" "),t("li",[t("p",[a._v("可以方便地与其他视图技术(JSP、FreeMarker等)进行整合。由于SpringMVC的模型数据往往是放置在Map数据结构中的，因此其可以很方便地被其他框架引用。")])]),a._v(" "),t("li",[t("p",[a._v("拥有十分简洁的异常处理机制。")])]),a._v(" "),t("li",[t("p",[a._v("可以十分灵活地实现数据验证、格式化和数据绑定机制，可以使用任意对象进行数据绑定操作。")])]),a._v(" "),t("li",[t("p",[a._v("支持RestFul风格。")])])]),a._v(" "),t("h4",{attrs:{id:"_2-4-spingmvc主要组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-spingmvc主要组件"}},[a._v("#")]),a._v(" 2.4 SpingMVC主要组件")]),a._v(" "),t("p",[a._v("前端控制器：接收前端请求，然后给用户反馈")]),a._v(" "),t("p",[a._v("处理器映射器：收集处理器")]),a._v(" "),t("p",[a._v("处理器适配器：执行处理器")]),a._v(" "),t("p",[a._v("视图解析器：根据ModelAndView返回具体的视图")]),a._v(" "),t("p",[a._v("视图：是一个接口")]),a._v(" "),t("p",[a._v("处理器：是请求的处理逻辑，返回相应的数据和视图信息，并封装到ModelAndView中")]),a._v(" "),t("h4",{attrs:{id:"_2-5-springmvc和struts2的区别有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-springmvc和struts2的区别有哪些"}},[a._v("#")]),a._v(" 2.5 SpringMVC和Struts2的区别有哪些?")]),a._v(" "),t("p",[a._v("入口不同、url的映射关系不同、")]),a._v(" "),t("h4",{attrs:{id:"_2-6-springmvc怎么样设定重定向和请求转发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-springmvc怎么样设定重定向和请求转发"}},[a._v("#")]),a._v(" 2.6 SpringMVC怎么样设定重定向和请求转发？")]),a._v(" "),t("p",[a._v("都是通过返回一个String")]),a._v(" "),t("p",[a._v('重定向： "redirect:页面"')]),a._v(" "),t("p",[a._v('转发："forward:页面"')]),a._v(" "),t("h4",{attrs:{id:"_2-7怎么样把modelmap里面的数据放入session里面"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-7怎么样把modelmap里面的数据放入session里面"}},[a._v("#")]),a._v(" 2.7怎么样把ModelMap里面的数据放入session里面？")]),a._v(" "),t("p",[a._v("使用@SessionAttributes 注解")]),a._v(" "),t("h4",{attrs:{id:"_2-8-dodispatcher的执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-dodispatcher的执行流程"}},[a._v("#")]),a._v(" 2.8 doDispatcher的执行流程")]),a._v(" "),t("p",[a._v("（1）调用mappedHandler = this.getHandler(processedRequest);  获取能够处理当前请求的执行链 HandlerExecutionChain （handler+拦截器）。")]),a._v(" "),t("p",[a._v("如何获取handler的？会遍历handlerMappings数组，对应的是不同的Mapper对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518867643421651886763638.png",alt:""}})]),a._v(" "),t("p",[a._v("（2）HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); 从执行链中获取handler调用getHandlerAdapter方法获取 HandlerAdapter 。")]),a._v(" "),t("p",[a._v("如何获取的handlerAdapter？会遍历handlerAdapters数组，对应的是不同的adapter对象。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16518930253451651893025237.png",alt:""}})]),a._v(" "),t("p",[a._v("（3）mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 调用HandlerAdapter 的handle方法去执行那个handler得到ModelAndView。")]),a._v(" "),t("p",[a._v("（4）this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 调用processDispatchResult方法结合mv完成视图渲染与跳转。")]),a._v(" "),t("h4",{attrs:{id:"_2-9九大组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-9九大组件"}},[a._v("#")]),a._v(" 2.9九大组件 ")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//多部件解析器")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MultipartResolver")]),a._v(" multipartResolver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//国际化解析器")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocaleResolver")]),a._v(" localeResolver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//主题解析器")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ThemeResolver")]),a._v(" themeResolver"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//处理器映射器组件 ")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HandlerMapping")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" handlerMappings"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//处理器适配器组件 ")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HandlerAdapter")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" handlerAdapters"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//异常解析器组件")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("HandlerExceptionResolver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" handlerExceptionResolvers"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//默认视图名转换器组件 ")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RequestToViewNameTranslator")]),a._v(" viewNameTranslator"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//flash属性管理组件")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FlashMapManager")]),a._v(" flashMapManager"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//视图解析器")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Nullable")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ViewResolver")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" viewResolvers"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("h4",{attrs:{id:"_3-0组件的初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-0组件的初始化"}},[a._v("#")]),a._v(" 3.0组件的初始化")]),a._v(" "),t("p",[a._v("tomcat启动后，会有事件触发DisplayServlet调用onRefresh 方法，然后进行调用方法进行初始化。")]),a._v(" "),t("h4",{attrs:{id:"_3-1-springmvc主要组件-五大组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-springmvc主要组件-五大组件"}},[a._v("#")]),a._v(" 3.1 SpringMVC主要组件（五大组件）；*\n")]),a._v(" "),t("p",[a._v("DispatcherServlet：前端控制器，用于请求到达前端控制器，由它调用其他组件处理用户的请求。")]),a._v(" "),t("p",[a._v("HandlerMapping：处理器映射器，负责根据用户请求找到Handler(处理器)，springmvc提供了不同的映射器实现方式。")]),a._v(" "),t("p",[a._v("Handler：后端控制器（处理器），对具体的用户请求进行处理。")]),a._v(" "),t("p",[a._v("HandlerAdapter：处理器适配器，通过HandlerAdapter对处理器进行执行。")]),a._v(" "),t("p",[a._v("View Resolver：视图解析器，负责将处理结果生成view视图。 ")]),a._v(" "),t("h4",{attrs:{id:"_3-2-springmvc有哪些注解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-springmvc有哪些注解"}},[a._v("#")]),a._v(" 3.2 SpringMVC有哪些注解")]),a._v(" "),t("p",[a._v("@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。")]),a._v(" "),t("p",[a._v("@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。")]),a._v(" "),t("p",[a._v("@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。")]),a._v(" "),t("p",[a._v("@Resource和@Autowired：@Resource和@Autowired都是做bean的注入时使用，其实            @Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。")]),a._v(" "),t("p",[a._v("@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数")]),a._v(" "),t("h4",{attrs:{id:"_3-3-springmvc怎么样设定重定向和转发的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-springmvc怎么样设定重定向和转发的"}},[a._v("#")]),a._v(" 3.3 SpringMVC怎么样设定重定向和转发的？")]),a._v(" "),t("p",[a._v('1、转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"')]),a._v(" "),t("p",[a._v('2、重定向：在返回值前面加"redirect:"，譬如"redirect:'),t("a",{attrs:{href:"http://www.baidu.com",title:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[a._v("http://www.baidu.com"),t("OutboundLink")],1),a._v('"可能会问转发与重定向的区别。 ')]),a._v(" "),t("h4",{attrs:{id:"_3-4-spring事务传播机制是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-spring事务传播机制是什么"}},[a._v("#")]),a._v(" 3.4 Spring事务传播机制是什么；\n")]),a._v(" "),t("p",[a._v("Spring事务定义了7种传播机制：")]),a._v(" "),t("p",[a._v("1、PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事 务，若不存在事务，则新建一个事务。")]),a._v(" "),t("p",[a._v("2、PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。")]),a._v(" "),t("p",[a._v("3、PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务，则新建一个事务，类似于REQUIRE_NEW。")]),a._v(" "),t("p",[a._v("4、PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。")]),a._v(" "),t("p",[a._v("5、PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂起。")]),a._v(" "),t("p",[a._v("6、PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常。")]),a._v(" "),t("p",[a._v("7、PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。")]),a._v(" "),t("h3",{attrs:{id:"_3-0-springboot面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-springboot面试题"}},[a._v("#")]),a._v(" 3.0 Springboot面试题")]),a._v(" "),t("h4",{attrs:{id:"什么是-spring-boot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-boot"}},[a._v("#")]),a._v(" 什么是 Spring Boot？")]),a._v(" "),t("ul",[t("li",[a._v("Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。")])]),a._v(" "),t("h4",{attrs:{id:"为什么要用springboot"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用springboot"}},[a._v("#")]),a._v(" 为什么要用SpringBoot")]),a._v(" "),t("ul",[t("li",[a._v("快速开发，快速整合，配置简化、内嵌服务容器")])]),a._v(" "),t("h4",{attrs:{id:"springboot与springcloud-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot与springcloud-区别"}},[a._v("#")]),a._v(" SpringBoot与SpringCloud 区别")]),a._v(" "),t("ul",[t("li",[a._v("SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。")])]),a._v(" "),t("h4",{attrs:{id:"spring-boot-有哪些优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-有哪些优点"}},[a._v("#")]),a._v(" Spring Boot 有哪些优点？")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Spring Boot 主要有如下优点：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。")])]),a._v(" "),t("li",[t("p",[a._v("开箱即用，远离繁琐的配置。")])]),a._v(" "),t("li",[t("p",[a._v("提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。")])]),a._v(" "),t("li",[t("p",[a._v("SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等")])])])])]),a._v(" "),t("h4",{attrs:{id:"spring-boot-的核心注解是哪个-它主要由哪几个注解组成的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-的核心注解是哪个-它主要由哪几个注解组成的"}},[a._v("#")]),a._v(" Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("@SpringBootConfiguration：组合了 @Configuration 注解，标注一个类为配置类，该类下的方法如果有@Bean, 那么会以方法名作为Bean的名字，返回值作为Bean的类型注入到Spring容器中。")])]),a._v(" "),t("li",[t("p",[a._v("@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如："),t("code",[a._v("java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。")])])]),a._v(" "),t("li",[t("p",[a._v("@ComponentScan：Spring组件扫描。会扫描该类包下的所有配置类")])])])])]),a._v(" "),t("h4",{attrs:{id:"springboot-starter的工作原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot-starter的工作原理"}},[a._v("#")]),a._v(" SpringBoot Starter的工作原理")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter")])])]),a._v(" "),t("li",[t("p",[a._v("在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）")])])]),a._v(" "),t("h3",{attrs:{id:"_3-0-java面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-java面试题"}},[a._v("#")]),a._v(" 3.0 java面试题")]),a._v(" "),t("h4",{attrs:{id:"_3-1-说一下-封装、继承、多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-说一下-封装、继承、多态"}},[a._v("#")]),a._v(" 3.1 说一下，封装、继承、多态")]),a._v(" "),t("p",[a._v("封装：把不想告诉或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开，别人只能用我提供的功能实现需求，而不知道是如何实现的。增加安全性。")]),a._v(" "),t("p",[a._v("继承：子类继承父类的数据属性和行为，并能根据自己的需求扩展出新的行为，提高了代码的复用性。")]),a._v(" "),t("p",[a._v("多态：多态性是对象多种表现形式的体现。")]),a._v(" "),t("p",[a._v("抽象：")]),a._v(" "),t("h4",{attrs:{id:"_3-2-string、stringbuffer、stringbuilder三者之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-string、stringbuffer、stringbuilder三者之间的区别"}},[a._v("#")]),a._v(" 3.2 String、StringBuffer、StringBuilder三者之间的区别")]),a._v(" "),t("p",[t("strong",[a._v("String")]),a._v(" "),t("strong",[a._v("字符串常量")])]),a._v(" "),t("p",[t("strong",[a._v("StringBuffer 字符串变量（线程安全）")])]),a._v(" "),t("p",[t("strong",[a._v("StringBuilder 字符串变量（非线程安全）")])]),a._v(" "),t("h4",{attrs:{id:"_3-3-string常用的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-string常用的方法"}},[a._v("#")]),a._v(" 3.3 String常用的方法")]),a._v(" "),t("p",[a._v("返回指定字符的索引：indexOf()")]),a._v(" "),t("p",[a._v("返回指定索引处的字符：charAt()")]),a._v(" "),t("p",[a._v("字符串替换：replace()")]),a._v(" "),t("p",[a._v("去除字符串两端空白：trim()")]),a._v(" "),t("p",[a._v("分割字符串，返回一个分割后的字符串数组：split()")]),a._v(" "),t("p",[a._v("返回字符串的 byte 类型数组：getBytes()")]),a._v(" "),t("p",[a._v("返回字符串长度：length()")]),a._v(" "),t("p",[a._v("将字符串转成小写字母：toLowerCase()")]),a._v(" "),t("p",[a._v("将字符串转成大写字符：toUpperCase()")]),a._v(" "),t("p",[a._v("截取字符串：substring()")]),a._v(" "),t("p",[a._v("字符串比较：equals()")]),a._v(" "),t("h4",{attrs:{id:"_3-4-反射"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-反射"}},[a._v("#")]),a._v(" 3.4 反射")]),a._v(" "),t("h4",{attrs:{id:"_3-5-jdb1-8的新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-jdb1-8的新特性"}},[a._v("#")]),a._v(" 3.5 JDB1.8的新特性")]),a._v(" "),t("p",[a._v("1 Lambda 表达式")]),a._v(" "),t("p",[a._v("2 方法引用 ")]),a._v(" "),t("p",[a._v("3 函数式接口")]),a._v(" "),t("p",[a._v("4 接口允许定义默认方法和静态方法")]),a._v(" "),t("p",[a._v("5 Stream API  ")]),a._v(" "),t("p",[a._v("6 日期/时间类改进 ")]),a._v(" "),t("p",[a._v("7 Optional 类")]),a._v(" "),t("p",[a._v("8 Java8 Base64 实现 ")]),a._v(" "),t("h4",{attrs:{id:"_3-6-异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-异常"}},[a._v("#")]),a._v(" 3.6 异常")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519929145191651992914201.png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"_3-7-jdk源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-jdk源码"}},[a._v("#")]),a._v(" 3.7 JDK源码")]),a._v(" "),t("p",[a._v("如果 HashMap")]),a._v(" "),t("h4",{attrs:{id:"_3-8-java集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-java集合"}},[a._v("#")]),a._v(" 3.8 Java集合")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519934905201651993485895.png",alt:""}})]),a._v(" "),t("p",[a._v("(1)Connection"),t("strong",[a._v("接口")]),a._v(":"),t("strong",[a._v("List")]),a._v(" 有序,可重复")]),a._v(" "),t("p",[t("strong",[a._v("ArrayList")]),a._v("  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程不安全，效率高 "),t("strong",[a._v("Vector")]),a._v("  优点: 底层数据结构是数组，查询快，增删慢。  缺点: 线程安全，效率低, 已给舍弃了 "),t("strong",[a._v("LinkedList")]),a._v("  优点: 底层数据结构是链表，查询慢，增删快。  缺点: 线程不安全，效率高"),t("strong",[a._v("Set")]),a._v(" 无序,唯一")]),a._v(" "),t("p",[t("strong",[a._v("HashSet")]),a._v("  底层数据结构是哈希表。(无序,唯一) 如何来保证元素唯一性? 依赖两个方法：hashCode()和equals()")]),a._v(" "),t("p",[t("strong",[a._v("LinkedHashSet")]),a._v("  底层数据结构是链表和哈希表。(FIFO插入有序,唯一)  ")]),a._v(" "),t("p",[a._v("1.由链表保证元素有序 2.由哈希表保证元素唯一")]),a._v(" "),t("p",[t("strong",[a._v("TreeSet")]),a._v("  底层数据结构是红黑树。(唯一，有序)  ")]),a._v(" "),t("ol",[t("li",[a._v("如何保证元素排序的呢? 自然排序  比较器排序 2.如何保证元素唯一性的呢?  ")])]),a._v(" "),t("p",[a._v("根据比较的返回值是否是0来决定")]),a._v(" "),t("p",[t("strong",[a._v("(2)Map")]),a._v("接口有四个实现类： ")]),a._v(" "),t("p",[t("strong",[a._v("HashMap")]),a._v("   基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null 键， 线程不安全。  "),t("strong",[a._v("HashTable")]),a._v("   线程安全，低效，不支持 null 值和 null 键； "),t("strong",[a._v("LinkedHashMap")]),a._v("   线程不安全，是 HashMap 的一个子类，保存了记录的插入顺序； "),t("strong",[a._v("TreeMap")])]),a._v(" "),t("p",[a._v("能够把它保存的记录根据键排序，默认是键值的升序排序，线程不安全。")]),a._v(" "),t("h4",{attrs:{id:"_3-9-hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-hashmap"}},[a._v("#")]),a._v(" 3.9 HashMap")]),a._v(" "),t("p",[a._v("底层：")]),a._v(" "),t("p",[a._v("JDK1.8前是数组+链表")]),a._v(" "),t("p",[a._v("JDK1.8后是数组+链表 或 数组+红黑树（当链表长度 ≥ 8 时，≤ 6 时退化为链表）。")]),a._v(" "),t("p",[a._v("首次put时才会创建数组，长度为16，超过负载因子75%的容量时，乘于加载因子，会调用rehash方法使变为原来的两倍。")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16519937367691651993736687.png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"_4-10-有符号与无符号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-10-有符号与无符号"}},[a._v("#")]),a._v(" 4.10 有符号与无符号")]),a._v(" "),t("p",[a._v("看它的二进制的最高位，如果是1为负数，0为正数。")]),a._v(" "),t("h4",{attrs:{id:"_4-11-原码、反码、补码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-11-原码、反码、补码"}},[a._v("#")]),a._v(" 4.11 原码、反码、补码")]),a._v(" "),t("p",[a._v("原码：就当前的")]),a._v(" "),t("p",[a._v("反码：符号位不变，其它按位取反。")]),a._v(" "),t("p",[a._v("补码：反码+1")]),a._v(" "),t("p",[a._v("特别地：0的反码、补码都是0 ； 正数的原码、反码、补码相同。")]),a._v(" "),t("p",[a._v("注意：计算算在运算的时候，都是以补码的方式来运算的。")]),a._v(" "),t("div",{staticClass:"language-javascript extra-class"},[t("pre",{pre:!0,attrs:{class:"language-javascript"}},[t("code",[t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("计算机运行\n将"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" 与"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v("都转为补码，然后进行二进制的"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("运算。再将结果由补码到原码（"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("反码")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("符号位除外取反")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("原码")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" 十进制  ）\n")])])]),t("p",[a._v("视频："),t("a",{attrs:{href:"https://www.bilibili.com/video/BV17y4y1275u",title:"https://www.bilibili.com/video/BV17y4y1275u",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.bilibili.com/video/BV17y4y1275u"),t("OutboundLink")],1)]),a._v(" "),t("h4",{attrs:{id:"_4-12"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-12"}},[a._v("#")]),a._v(" 4.12 >>  >>>")]),a._v(" "),t("p",[a._v("对应右移和无符号右移")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/18476305640/typora@master/image/16520002231541652000222829.png",alt:""}})]),a._v(" "),t("h4",{attrs:{id:"_4-13-hashmap与hashtable-concurrenthashmap区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-13-hashmap与hashtable-concurrenthashmap区别"}},[a._v("#")]),a._v(" 4.13 HashMap与HashTable   ConcurrentHashMap区别")]),a._v(" "),t("p",[a._v("HashMap是线程不安全的，而HashTable与ConcurrentMap 都是线程安全的，只不过实现线程安全的方法不同。")]),a._v(" "),t("p",[a._v("HashTable一般现在不建议用 HashTable, ①是 HashTable 是遗留类，内部实现很多没优化和冗余。②即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用HashTable。")]),a._v(" "),t("p",[a._v("HashTable 使用的是 Synchronized 关键字修饰，ConcurrentHashMap 是JDK1.7使用了锁分段技术来保证线程安全的。JDK1.8ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。")]),a._v(" "),t("h3",{attrs:{id:"_4-0-mq面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-mq面试题"}},[a._v("#")]),a._v(" 4.0 MQ面试题")]),a._v(" "),t("h4",{attrs:{id:"_4-1rabbitmq-上的一个-queue-中存放的-message-是否有数量限制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1rabbitmq-上的一个-queue-中存放的-message-是否有数量限制"}},[a._v("#")]),a._v(" 4.1RabbitMQ 上的⼀个 queue 中存放的 message 是否有数量限制？")]),a._v(" "),t("p",[a._v("可以认为是⽆限制，因为限制取决于机器的内存，但是消息过多会导致处理效率的下降。")]),a._v(" "),t("h4",{attrs:{id:"_4-2-如何确保消息不丢失"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-如何确保消息不丢失"}},[a._v("#")]),a._v(" 4.2 如何确保消息不丢失？")]),a._v(" "),t("p",[a._v("将交换器/队列的durable属性设置为true，表示交换器/队列是持久交换器/队列，在服务器崩溃或重启之后不需要重新创建交换器/队列（交换器/队列会⾃动创建）。")]),a._v(" "),t("h4",{attrs:{id:"_4-3如何确保消息正确地发送至rabbitmq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3如何确保消息正确地发送至rabbitmq"}},[a._v("#")]),a._v(" 4.3如何确保消息正确地发送⾄RabbitMQ？")]),a._v(" "),t("p",[a._v("将信道设置成confirm模式（发送⽅确认模式），则所有在信道上发布的消息都会被指派⼀个唯⼀的ID。⼀旦消息被投递到⽬的队列后，或者消息被写⼊磁盘后（可持久化的消息），信道会发送⼀个确认给⽣产者（包含消息唯⼀ID）。如果RabbitMQ发⽣内部错误从⽽导致消息丢失，会发送⼀条nack（not acknowledged，未确认）消息。")]),a._v(" "),t("h4",{attrs:{id:"_4-4-如何确保消息接收方消费了消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-如何确保消息接收方消费了消息"}},[a._v("#")]),a._v(" 4.4 如何确保消息接收⽅消费了消息？")]),a._v(" "),t("p",[t("strong",[a._v("接收⽅消息确认机制")]),a._v("：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。")]),a._v(" "),t("h4",{attrs:{id:"_4-5-如何避免消息重复投递或重复消费"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-如何避免消息重复投递或重复消费"}},[a._v("#")]),a._v(" 4.5 如何避免消息重复投递或重复消费？")]),a._v(" "),t("p",[a._v("使用消息的全局ID，在消费消息时判断之前是否已消费了该消息，如果消息就不再消费，从而避免重复消费。")]),a._v(" "),t("h4",{attrs:{id:"_4-6-消息基于什么传输"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-6-消息基于什么传输"}},[a._v("#")]),a._v(" 4.6 消息基于什么传输？")]),a._v(" "),t("p",[a._v("RabbitMQ使⽤信道的⽅式来传输数据。信道是建⽴在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。")]),a._v(" "),t("h4",{attrs:{id:"_4-7-queue队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-7-queue队列"}},[a._v("#")]),a._v(" 4.7 .Queue队列？")]),a._v(" "),t("p",[a._v("Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。")]),a._v(" "),t("h4",{attrs:{id:"_4-8-exchange交换器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-8-exchange交换器"}},[a._v("#")]),a._v(" 4.8.Exchange交换器？")]),a._v(" "),t("p",[a._v("Exchange:生产者将消息发送到交换器，有交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。")]),a._v(" "),t("h4",{attrs:{id:"_4-9-routingkey路由键"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-9-routingkey路由键"}},[a._v("#")]),a._v(" 4.9 RoutingKey路由键？")]),a._v(" "),t("p",[a._v("生产者将消息发送给交换器的时候，会指定一个RoutingKey,用来指定这个消息的路由规则，这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。")]),a._v(" "),t("h4",{attrs:{id:"_4-10-交换机类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-10-交换机类型"}},[a._v("#")]),a._v(" 4.10  交换机类型")]),a._v(" "),t("p",[a._v("fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。")]),a._v(" "),t("p",[a._v("direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。")]),a._v(" "),t("p",[a._v("topic:")])])}),[],!1,null,null,null);t.default=e.exports}}]);