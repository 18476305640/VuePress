(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{322:function(n,e,t){"use strict";t.r(e);var a=t(10),o=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"javascrit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascrit"}},[n._v("#")]),n._v(" Javascrit")]),n._v(" "),e("h2",{attrs:{id:"目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[n._v("#")]),n._v(" 目录")]),n._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"#%E5%9F%BA%E7%A1%80"}},[n._v("基础")])]),n._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"}},[n._v("基本知识")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"}},[n._v("内置对象")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#dom"}},[n._v("DOM")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#bom"}},[n._v("BOM")])])])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E9%AB%98%E7%BA%A7"}},[n._v("高级")])]),n._v(" "),e("ul",[e("li",[e("p",[e("a",{attrs:{href:"#%E5%AF%B9%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3"}},[n._v("对基础知识的深入了解")])])]),n._v(" "),e("li",[e("p",[e("a",{attrs:{href:"#%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86"}},[n._v("高级部分")])])])])])]),n._v(" "),e("h2",{attrs:{id:"基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[n._v("#")]),n._v(" 基础")]),n._v(" "),e("h3",{attrs:{id:"基本知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本知识"}},[n._v("#")]),n._v(" 基本知识")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("数据类型")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("数据类型\n在js中有六种数据类型\n（基本数据类型）\nString ：在双引放单引\nNumber :包括整数与浮点数；\n如何数值超过Number.Max_value则会返回infinity(无穷的数值类型)；NaN也是一个数值类型。但他想表示这不是一个数值类型；对于精确度比较高的，千万不要使用JS运算，比如0.1+0.2得到的结果不准确。\nBoolean\nNull :使用typeof检查是Object类型\nUndefined 未定义，当我们声明一个变量，但没有赋值，输出时就会返加Undefined\n（引用数据类型）\nObject\t对象")])]),n._v(" "),e("li",[e("p",[n._v("数据类型的判断函数\n1-1、typeof 不可以判断null Object\n1-2、instanceof 对typeof进行补充，用来判定Object(具体)\n语法： 目标 instanceof  类型 ----判断左边是否是右边的实例\n   1-3、“===” 对typeof进行补充, 可以用来判断 null undefined")])]),n._v(" "),e("li",[e("p",[n._v('数据类型的转换\n1、a.toString()与String(a)函数转字符串\n---前者有局限性，当a是null或Undefined类型时，会出现错误。\n2、Number(a)函数转为数值类型\n--null、boolean比较特别，他在一定方面代表的是数字，会转为数字。而不是NaN;\n3、转布尔值的Boolean(a)函数(比较重要)\n--【数字类型】0，NaN【字符类型】空串 ""以及【null】【Undefined】【Object】上面除了Object都转为false')])])])]),n._v(" "),e("li",[e("p",[n._v("转意字符\n\\n 换行   对应HTML  ")]),n._v(" "),e("p",[n._v("\\t 制表(tab)   对应HTML")])]),n._v(" "),e("li",[e("p",[n._v("数值解析")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('数字解析\nparseInt(a)，parseFloat(a)两个函数\n列举：0.123.4c.123\n---parseInt(a),解析得0，原理是从左到右只解析数字，遇非数字结束。除此还可以用来解析进制数parseInt(123,8)\n深入应用：\n如何获取var i=134;的百十个位数呢？\n答：var bai=parseInt(i/100);\nvar shi=parseInt((i%100)/10);\nvar ge=i%10;\n快速理解：先% 后parseInt()+"/"')]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("        ---parseFloat(a)，解析得0.123,从左到右解析数值，包括第一个小数点。\n")])])])]),n._v(" "),e("li",[e("p",[n._v("字符解析\n以0x、0、0b开头分别代表什么进制数，分别是十六进制、八进制、十进制。\n'\\u + 16进制的unicode编码'\n'&# + 10进制的unicode编码 + 英文分号;'")])])])]),n._v(" "),e("li",[e("p",[n._v("运算")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('运算符+\n不同数据类型进行加法运算, 主要看一对运算中是否有String、NaN.且优先级String>NaN,\n举例：1+null+"abc"=1abc')])]),n._v(" "),e("li",[e("p",[n._v("非加运算符-*%\n不管是何类型都转为Number运算。结果不是数字就是NaN; \n--原理是，从左到右将非数字类型转为数字类型如果转换失败，得到NaN,因为所有数值与NaN运算都是NaN,所以结束是NaN.")])]),n._v(" "),e("li",[e("p",[n._v("等号与自增自减运算\n等号运算，“==”与“===”的区别在于是否会作转换，“===”是作全等运算。而“==”转换数据类型转换后进行全等运算。\n自增有a++，++a 区别在于第一次代表的值。而后面他的值是一样的，都是自增后的值。\n例举： var a=1;\nvar b=1;\n \tconsole.log(a++,++b);//第一次，"),e("em",[n._v("1 2")]),n._v("\nconsole.log(a,b);//第二次，"),e("em",[n._v("2 2")]),n._v("\n（-- 略）")])]),n._v(" "),e("li",[e("p",[n._v("三目运算\nBoolean  ? A区：B区;三目运算符可以是语句块，也可以是某个值。\n--补充：如果区是代码块最终变量是没能得到值的。")])]),n._v(" "),e("li",[e("p",[n._v("赋值运算\na=4与a[+-*/%]=b\n--前者是单纯的赋值运算，而后者是表达式赋值。\n--后者：a+=b  ==> a=a+b;")])]),n._v(" "),e("li",[e("p",[n._v("逻辑运算\n首先将两边代码结果进行 ”布尔化“，根据&& （||），\n进行从左到右找false(true)。如果找到返回位置上对应的内容，如果没找到返回最后一位的内容。")])]),n._v(" "),e("li",[e("p",[n._v("关系运算\na>b,类似运算中，会将他们数值化，如果都是字符类型则不会数值化，而是比较他们的Unicode编码。如果在数值化过程中转为了NaN,则最后结束是false.")])])])]),n._v(" "),e("li",[e("p",[n._v("语句")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("条件语句\nif语句： 完整语句体\nif(Boolean){\nswitch语句\nswitch(i){\ncase a:\n代码体1\nbreak;\ncase b:\n代码体2\nbreak;\ndefault:\n代码块3\nbreak;\n}")]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("     }else if(Boolean){\n\n    }else{\n\n    }\n")])])])]),n._v(" "),e("li",[e("p",[n._v("循环语句\n共性：初始化表达式、条件表达式、更新表达式。\n【循环语句while】while的结构是分散的。写法是从死循环到标准。\n【循环语句for】for循环语句与while相比，for的结构是在一起的。而执行的顺序如下：\nfor(1初始化表达式;2,5/,8/...条件表达式;4,7,...更新表达式){\n3,6,...代码块\n}")])]),n._v(" "),e("li",[e("p",[n._v("补充\nbreak(switch || 循环) ，continue专门用于循环")])])])]),n._v(" "),e("li",[e("p",[n._v("对象")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n存储不同数据类型的容器，\n可以向里面添加任意的数据类型，包括对象，函数，数组与其它对象。")])]),n._v(" "),e("li",[e("p",[n._v('工厂创建\n工厂模式\n将公共方法存到原型对象中，从而避免每创建一个对象就创建一个属性，来节省内存空间。\nfunction Pro(name,age){\nthis.name=name;\nthis.age=age;\nPro.prototype.setName=function (newName){\nthis.name=newName;\n}\n}\nvar pro=new Pro("小庄",23);\n补充：\nthis代表新创建的对象\nnew就是调用了构造函数进行创建，其执行流程：\n1、立刻创建一个新的对象，\n2、将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象\n3、逐行执行函数中的代码//由我们书写，其它步骤不可见\n4、将新建的对象作为返回值返回\n使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。通过一个构造函数创建的对象，称为是该类的实例。')])]),n._v(" "),e("li",[e("p",[n._v('添加\n用方法添加\n--obj.nama  ="";\nobj["name"]="";\n用快捷表达法添加\n{\nname:123,\n"123":345\n}\n注意向对象添加的属性名可以不用符合标签符命名规则，但添加的方式需要用引号括起。')])]),n._v(" "),e("li",[e("p",[n._v('读取\n普通\nobj.element\n特殊（对应添加）\nobj["123"]')])]),n._v(" "),e("li",[e("p",[n._v('查找\n检查obj是否包含有element属性\nvar  ifs=("element" in obj);')])]),n._v(" "),e("li",[e("p",[n._v("删除\n删除obj中的element属性\ndellete  obj.element")])]),n._v(" "),e("li",[e("p",[n._v('遍历\n枚举\nfor(var n in obj){\nconsole.log(n+":"+obj[n]);\n//如果obj.n是在obj中找属性名为n 的属性值，但肯定是没有的，我们需要《样做。\n}')])])])]),n._v(" "),e("li",[e("p",[n._v("原型对象")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n原型对象：\n不管在Object对象，函数(包括Function函数)，还是实例对象中，都有原型对象。且他们是存在有关系的。（请看附件）")])]),n._v(" "),e("li",[e("p",[n._v('属性的查找\n关于检查：\nhasOwProperty：用来检查对象本身是否含有指定的属性\npro.hasOwnProperty("name")\n"属性" in 对象.用来检查本身及其原型是否包含指定属性。\n举例：\nfunction Pro(name){\nthis.name=name;\n}\nvar pro=new Pro("孙悟空");\npro.'),e("strong",[n._v("proto")]),n._v('.age=23;\nconsole.log(pro.hasOwnProperty("name"));\nconsole.log("age" in pro);')])])])]),n._v(" "),e("li",[e("p",[n._v("函数")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n函数本身也是对象，里面包含了可执行的代码。函数用来实现特定的功能。\n分类：\n(函数本身也是对象)\nvar at3=new Function(\"console.log('原始');\");\nat3();\n （有函数名）\nfunction fun1(){\n对象中的函数\n--方法")]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('    }\n  (无函数名)\n    有接收:\n    var fun=function(){\n      \n    }\n    无接收（立即执行函数）:\n    (function(a){\n      \n    })("a")\n')])])])]),n._v(" "),e("li",[e("p",[n._v("作用域\n全局变量作用域生命周期是由网页打开到关闭。\n而函数变量（局部）作用域从调用到调用结束。")])]),n._v(" "),e("li",[e("p",[n._v("this\n在函数中，用对象调用，this就是该对象。\n在函数中，用函数的返回值调用，this是Window.\n在构造函数中，this代表的是新创建的对象。\n改变this:\nPer.call(obj,2,3);//依次传参\nPer.apply(obj,[2,3]);//以数组的形式传参")])]),n._v(" "),e("li",[e("p",[n._v("类数组arguments\narguments，在函数中arguments包含了传进来的所以参数，而不限于形参。\narguments是一个类数组，我们可以获取里面的包含的参数。\n我们也可以将这个类数据转为真正的数组。\nvar args = Array.prototype.slice.call(arguments);\n除此\n我们还可以利用其cellee属性得到最近最近外围的函数。来实现递归。\nvar num=1;\nfunction fu(){\nconsole.log(num++);\narguments.callee();//相当于fu()\n}\nfu();")])])])]),n._v(" "),e("li",[e("p",[n._v("垃圾回收\n当一个对象，没有变量指向它的时候，js垃圾回收器就会自动 回收这些内存资源。")])])]),n._v(" "),e("h3",{attrs:{id:"内置对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置对象"}},[n._v("#")]),n._v(" 内置对象")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("数组")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n数组是用来存储数据的，可以存储任意的数据类型。可以将其看作一个容器。")])]),n._v(" "),e("li",[e("p",[n._v('基本使用\n数组是Array对象，快速用[]快速创建。\n向后添加数据\narr[arr.length]="new \n替换方法\narr.splice(开始索引 , 向后数量 ,"新数组属性");')])]),n._v(" "),e("li",[e("p",[n._v('数组的遍历\n两种方法：\nvar arr=[1,2,3,4];\n专门用于遍历数组的forEach方法（不可中途终止遍历）\narr.forEach(function(val,ind){\nconsole.log("索引="+ind+",值="+val);\n});\n使用性更广的for循环遍历（可中途终止遍历）\nfor(var i=0;i<arr.length;i++){\nconsole.log("索引="+i+",值="+arr[i]);\nif(i==2){\nbreak;\n}\n}')])])])]),n._v(" "),e("li",[e("p",[n._v('时间对象Date\n获取时间对象\nvar auto=new Date();//获取当前时间\nvar din=new Date("05/20/2020 13:14:00");//自定义一个时间\n时间对象的一些方法\ngetDate()\t以数值返回天（1-31）\ngetDay()\t以数值获取周名（0-6）\ngetFullYear()\t获取四位的年（yyyy）\ngetHours()\t获取小时（0-23）\ngetMilliseconds()\t获取毫秒（0-999）\ngetMinutes()\t获取分（0-59）\ngetMonth()\t获取月（0-11）\ngetSeconds()\t获取秒（0-59）\ngetTime()\t获取时间（从 1970 年 1 月 1 日至今）\nconsole.log(auto.getTime());//获取指定时间的时间戳\nvar start=Date.now();//获取现在的时间戳。')])]),n._v(" "),e("li",[e("p",[n._v("数学对象Math\nMath对象（数学工具类）\nMath.floor(x) 的返回值是 x 下舍入最接近的整数：\nMath.ceil(x) 的返回值是 x 上舍入最接近的整数：\nMath.round(x) 的返回值是 x 四舍五入为最接近的整数：\nMath.random() 返回 0（包括） 至 1（不包括） 之间的随机数：\n获取X到Y的随机整数\nMath.round( Math.random()*(y-x)+x )")])]),n._v(" "),e("li",[e("p",[n._v("包装类\n这个内容只需要理解即可，因为它是由底层使用的。\n关于包装类：\n为什么基本数据类型也可以用toString方法？\n为什么我们可以基本数据类赋值，却调用不了？\n因为当我们用基本数据类型调用一些方法时，底层会自动将基本数据类型转为对象。\na.toString()====\nvar b=new Number(a);\nconsole.log(b.toString());")])]),n._v(" "),e("li",[e("p",[n._v('操作字符的一些方法\n根据索引获取指定字符     ut.charAt(1);\n连接字符串           \t\t\t ut.concat("567","890");\n截取字符串中的内容     \t ut.slice(1,-1); [起来s]\n将字符串进行拆分为数组    name.split(","); [cplit]')])]),n._v(" "),e("li",[e("p",[n._v('正则表达式\ntest方法：检查右边的字符是否符合左边的正则\nRegExp对象：动态修改正则表达式， new RegExp("\\b"+cn+"\\b");,会返回一个正则表达式对象\nstr.match(/[a-z]/ig); match方法将在左边满足的字符，装箱为一个数组。所以需要用全局g.\n(ig免忽略大小写且进行全局匹配，还有m执行多行匹配。)\n"".replace(//,"")利用正则进行替换字符')]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('        （对字符的描述）\n           [abc]、[A-z0-9]，\n           \\w 查找数字、字母、_\n           \\d  查找数字。\n           \\s  查找空白字符。\n           \\b  匹配单词边界。\n         （字符量词）\n          {n,m}左边一个字符或一个（）组出现n到m次，{m}出现m次，{m,}出现m次以上。\n          +至少一个==={1,}\n          *有没有都可以{0,}\n          ?有或没有\n         （字符位置）\n          /^n/前面不能再有字符，\n          /n$/后面不能再有字符\n          /^n$/完全符合正则表达式，即：只能是str="n";才满足。\n')])])])])]),n._v(" "),e("h3",{attrs:{id:"dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dom"}},[n._v("#")]),n._v(" DOM")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("事件")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n我们给某个对象绑定事件，我们可以写触发后要执行的代码。\n有点击，双击，移入，移出，键盘，滚轮等事件。")])]),n._v(" "),e("li",[e("p",[n._v("加载事件\nonload事件：由于文档加载自上而下的原因，我们需要用到这个事件，以免当我们对文档进行操作时，其对象不存在（还未加载 ）\n应用\nwindow.onload=function(){\n//当文档加载完成后，会自动触发执行\n}")])]),n._v(" "),e("li",[e("p",[n._v("焦点事件\n【焦点事件】\n    onfocus得到焦点\n    onblur失去焦点事件")])]),n._v(" "),e("li",[e("p",[n._v("键盘事件\n键盘事件\nonkeydown键按下事件\n    onkeyup键松开事件\n    识别按下是哪个键：\n      在键盘事件触发后，获取传入的参数event,可以根据event.keyCode==键码，根据特殊的\n      event.altKey,event.shiftKey等，\n      多键识别：我们可识别特殊键+非特殊键\n    取消默认键盘行为\n      键盘事件触发后，return false;时，在输入框时输入将无法正常使用。")])]),n._v(" "),e("li",[e("p",[n._v("单击/双击事件\n单击事件\nup.onclick=function(){\n//要执行的代码\n};\n双击事件\nup.ondbclick=function(){\n//要执行的代码\n}")])]),n._v(" "),e("li",[e("p",[n._v("滚动条事件\nonscroll 事件：当我们滑动滚动条时触发\n使用： info.onscroll=function(){}\n获取滚动条的一些信息：\n//info.scrollHeight是总高度\n//info.scrollTop当前滚动条到top的长度\n//info.clientHeight可见页面高度\n扩展：\n组件可用性：disabled=true|false;")])]),n._v(" "),e("li",[e("p",[n._v('滚轮事件\n滚轮事件\nbox.onmousewheel = function(event) {//滚动触发\n  event = event || window.event;\n  if (event.wheelDelta > 0 || event.detail < 0) {//判断是否是下滚动且兼容\n    box.style.height = box.clientHeight - 10 + "px";\n  } else {\n    box.style.height = box.clientHeight + 10 + "px";\n}\n  event.preventDefault && event.preventDefault(); //解决连带滚动条滚动问题,&&当可用时执行\n  return false; //取消默认行为（滚动默认连动总页面滚动）\n}\n//解决滚轮事件浏览器兼容问题，如果是火狐，它是不支持onmousewheel事件的，\nbind(box, "DOMMouseScroll", box.onmousewheel);\nfunction bind(obj, eventStr, callback) { //事件监听兼容函数\n  if (obj.addEventListener) {\n    obj.addEventListener(eventStr, callback, false);\n  } else {\n    obj.attachEvent("on" + eventStr, function() {\n      callback.call(obj);\n    });\n  }\n}')])])])]),n._v(" "),e("li",[e("p",[n._v("节点")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('获取节点\n【获取节点】\n（document）\ndocument.getElementById("bt");//根据Id获取节点\ngetElementsByTagName("li");//演示根据标签名获取组属性\ndocument.getElementsByName("user");//演示根据name的属性获取组属性\nvar bufu=document.querySelectorAll("#imgbox"); //根据css选择器获取组节点\n【获取关系节点】\nfu.children;//获取全部子属性节点\ndown.parentNode;//获取父节点\ndown.previousElementSibling;//获取前一个兄弟节点\ndown.nextSibling;//获取后一个兄弟节点')])]),n._v(" "),e("li",[e("p",[n._v('创建节点\n【创建节点与节点关系】\nvar but=document.createElement("button");//创建一个属性节点\nvar btext=document.createTextNode("最后一张"); //创建一个文本节点（可在父节点用innerHTML代替）\nbut.appendChild(btext);//将新节点插入指定节点下\nbufu.insertBefore(but,down);//将新的节点插入指定的子节点之前。\nbufu.replaceChild(but,down);//将新节点代替旧节点\nbut.parentNode.removeChild(but);//删除子节点')])]),n._v(" "),e("li",[e("p",[n._v("读取节点\n读取节点的属性与内部HTML代码\nbt.value;//读节点属性。\n（class属性是保留字，需要.className去读取）\nbt.innerHTML;//读内部HTML代码 \nbt.innerText;//获取除标签外的全部内部文本")])]),n._v(" "),e("li",[e("p",[n._v("应用")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('修改样式\n为属性设置内部样式属性\nobj.style.backgroundColor="red";\n除此，我们还可以通过修改Class值来添加或删除一组样式。')])]),n._v(" "),e("li",[e("p",[n._v("读取样式\n利用下面的方法可以读取现在正在显示的样式\nfunction getStyle(obj,name){//读取现在的样式属性值\nif(window.getComputedStyle){\n  //大部分浏览器支持\n  return getComputedStyle(obj,null)[name];\n}else{\n  //只有IE8支持\n  return obj.currentStyle[name];\n}\n}")])])])])])]),n._v(" "),e("li",[e("p",[n._v("捕获与冒泡\n如果以父子关系依次相关联的，当子事件被触发时，以W3C的标准，分为从document到目标的捕获阶段，再到从目标向外的冒泡阶段。如果我们想在捕获时执行，需要在事件监听器\nobj.addEventListener(eventStr,callback,false);")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('事件的冒泡\n子元素事件被触发会自动触发相同事件的父元素。\n取消冒泡\nvar maot = document.getElementById("maoTest"); //取消冒泡\n    maot.onmousemove = function(event) {\n        event.cancelBubble = true; //隔板生效\n    }')])]),n._v(" "),e("li",[e("p",[n._v("事件的委派\n每个事件被触发后执行的函数都可以接收一个参数，他封装了一些信息，如由于事件的冒泡，我们不确定是谁触发的自己，这时参数对象有一个target属性，可以得到最先被触发的那个对象。")])])])]),n._v(" "),e("li",[e("p",[n._v("自定义方法")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('拖拽函数\n使用方法：只需传入要移动对象即可。\nfunction Tuo(box){ //拖拽函数\n//给box添加一个鼠标按下事件\nbox.onmousedown=function(event){\n//获取点击时在box中的相对位置x2,y2\nvar  x2=event.clientX-box.offsetLeft;//\nvar  y2=event.clientY-box.offsetTop;\n//给document添加一个拖拽事件\ndocument.onmousemove=function(event){\n//将传进来的event参数加强兼容性\nevent=event || window.event;\n//获取鼠标在document中的位置\nvar  x=event.clientX;\nvar  y=event.clientY;\n//修改box中的top与left属性\nbox.style.top=y-y2+"px";\nbox.style.left=x-x2+"px";\n}\n}')]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  }\n  document.onmouseup=function(){//当松下后，关闭移动与松下事件\n      document.onmousemove=null;\n      document.onmouseup=null;\n  }\n  return false; //解决全选后拖拽不了的问题\n  \n  \n")])])])]),n._v(" "),e("li",[e("p",[n._v("方向键移动函数\nbox ：是要移动的对象\na ：是物体移动的速度\nfunction boxmove(box, a){\nvar fan;//移动的方向\n//当按下一个键时，改变方向变量fan的值。松开时设置为空。\n//即我们按下时就朝着设置好的方向移动，松开后没有移动方向。\ndocument.onkeydown=function(event){\nfan=event.keyCode;\ndocument.onkeyup=function(){\nfan=null;\n}\n}")]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('  }\n  \n  var  yidon=setInterval(function(){\n    switch(fan){\n      case 37:\n        box.style.left=box.offsetLeft-a+"px";\n        break;\n      case 38:\n        box.style.top=box.offsetTop-a+"px";\n        break;\n        \n      case 39:\n        box.style.left=box.offsetLeft+a+"px";\n        break;\n      case 40:\n        box.style.top=box.offsetTop+a+"px";\n        break;\n  }            \n  },30);    \n')])])])])])])]),n._v(" "),e("h3",{attrs:{id:"bom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bom"}},[n._v("#")]),n._v(" BOM")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识BOM\n浏览器对象模型BOM")])]),n._v(" "),e("li",[e("p",[n._v('Navigator\n【Navigator】\n--获取浏览的信息，识别不同浏览器\nvar  ua=navigator.userAgent;\nif(/firefox/i.test(ua)){\n  alert("你是火狐");\n}else if(/chrome/i.test(ua)){\n  alert("你是谷歌");\n}else if(/msie/i.test(ua)){\n  alert("你是IE");\n}else if("ActiveXObject" in window){\n  alert("你是IE11，枪毙了你~");\n}')])]),n._v(" "),e("li",[e("p",[n._v('Location\n【Location】\n--代表浏览的地址栏\n//执行后会跳转到指定链接上\nlocation.assign("'),e("a",{attrs:{href:"http://www.baidu.com",title:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://www.baidu.com"),e("OutboundLink")],1),n._v('");\n//执行后会清除缓存\nlocation.reload(true);\n//执行后会替换当前，且不可逆。\nlocation.replace("'),e("a",{attrs:{href:"http://www.baidu.com",title:"http://www.baidu.com",target:"_blank",rel:"noopener noreferrer"}},[n._v("http://www.baidu.com"),e("OutboundLink")],1),n._v('");')])]),n._v(" "),e("li",[e("p",[n._v("History\n【History】\n--当前容器的历史记录\nhistory.back();//当前窗口的上一个页面\nhistory.go(-2);//跳转到前第二个页面\nhistory.forward();//当前窗口的下一个页面")])]),n._v(" "),e("li",[e("p",[n._v("screen\n【screen】\n--获取显示器的相关信息")])]),n._v(" "),e("li",[e("p",[n._v("定时器&超时调用\n定时器\nsetInterval(function(){\n},<循环调用时间>);\nclearInterval( );//关闭指定的定时器\n超时调用\nsetTimeout（function(){\n},<调用时间>);\nclearTimeou //关闭指定的超时调用")]),n._v(" "),e("ul",[e("li",[e("p",[n._v('自定义的方法\n/*\n1、动画函数\nobj：目标属性\nspeed：改变的速度\ntarget:改变的幅度\ntype:top\\left\\width\\height\nfun:回调函数，动画执行完时调用\n*/\nfunction move(obj, speed,target,type,fun){\nconsole.log("你调用了jsTools中的move动画函数~");\nfunction  getStyle(obj , name){//根据样式名获取样式值\nif(window.getComputedStyle){\nreturn getComputedStyle(obj,null)[name];\n}else{\nreturn obj.currentStyle[name];\n}\n}\n//函数主体\nclearInterval(obj.ding);\nif(parseInt(getStyle(obj,type))>target){\nspeed=-speed;\n}\nobj.ding=setInterval(function(){\nvar oldValue=parseInt(getStyle(obj,type));\nvar newValue=oldValue+speed;\nif((speed<0 && newValue < target ) ||( speed>0 && newValue > target) ){\nnewValue=target;\nobj.style[type]=newValue+"px";\nclearInterval(obj.ding);\nfun ?fun(): console.log("未传入回调函数");//执行回调函数\n}else{\nobj.style[type]=newValue+"px";\n}\n}\n/*\n2、添加或删除指定Class值\nobj：目标属性\ncn:是要添加或移除的Class值\n*/\nfunction hasClass(obj,cn){//有添加，无删除Class指定值\nvar ze=new RegExp("\\b"+cn+"\\b");\nif(ze.test(obj.className)){\nobj.className=obj.className.replace(ze,"");\nconsole.log("已替换");\n}else{\nobj.className+=" "+cn;\nconsole.log("已添加");\n}\n}\nfunction AddClass(obj,cn){//没有添加 \nvar ze=new RegExp("\\b"+cn+"\\b");\nif(! ze.test(obj.className)){\nobj.className+=" "+cn;\n}\n}\nfunction RemoveClass(obj,cn){//有移除\nvar ze=new RegExp("\\b"+cn+"\\b");\nobj.className=obj.className.replace(ze,"");\n}\n/*\n3、二级菜单伸缩动画函数\n使用说明：给具有指定结构的二级菜单栏添加伸缩动画效果\n<div id="my_menu" class="sdmenu">\n<div class="collapsed">\n在线工具图像优化\n...\n支持我们图像优化收藏夹图标\n....')]),n._v(" "),e("p",[e("em",[n._v('/\nfunction mocc(boxId){\nvar box=document.getElementById(boxId);\n//获取二级菜单主体下的span\nvar title=box.getElementsByTagName("span");\nvar index;\n//遍历span\nfor(var i=0;i<title.length;i++){\ntitle[i].index=i;\ntitle[i].ofno=false;\n//为每个span绑定一个单击响应函数\ntitle[i].onclick=function(){\n//得到当前span的父节点,与其下一个兄弟\nvar Tparent=this.parentNode;\nvar Tsibling=this.nextElementSibling;\nif(Tsibling){\n//分别得到展开前后的动态值\nvar init=Tparent.querySelector("span").offsetHeight;\nvar end=Tparent.querySelectorAll("a").length')]),n._v('(Tsibling.offsetHeight)+init;\n//根据现在的状态，给等下要操作的目标长度赋值 后修改操作后的状态\nvar mo=this.ofno ? init :end;\nthis.ofno ? (this.ofno=false) : (this.ofno=true);\nmove(Tparent,6, mo,"height",function(){\n});\n}')]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("          },30);\n          \n")])])]),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("          }\n        }\n      }\n")])])])])])])]),n._v(" "),e("h2",{attrs:{id:"高级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级"}},[n._v("#")]),n._v(" 高级")]),n._v(" "),e("h3",{attrs:{id:"对基础知识的深入了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对基础知识的深入了解"}},[n._v("#")]),n._v(" 对基础知识的深入了解")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("函数参数\n我们给函数传入参数时，就相当于在函数作用域中声明了一个变量。")])]),n._v(" "),e("li",[e("p",[n._v("资源的回收\n自动释放：生命周期完后\n回收:没有变量指定这个内存地址后，这块内存就会被回收器回收。")])]),n._v(" "),e("li",[e("p",[n._v('[]在对象中的应用\nvar obj={\n"a-b":123,\n"123":"ab"\n }\nconsole.log(obj["a-b"]); //特殊属性名时\nvar  name="a-b";//属性名不确定时\nconsole.log(obj[name]);')])]),n._v(" "),e("li",[e("p",[n._v("回调函数\n什么是回调函数？\n---你定义了，没有调用，但最后执行了。\n比如：事件 、定时器")])]),n._v(" "),e("li",[e("p",[n._v("IIFE\nIIFE ——立即执行函数的作用\n---不会污染全局命名空间，隐藏实现。")])]),n._v(" "),e("li",[e("p",[n._v("isAdd分号?\n关于加不加分号问题\n---小括号、中括号 前不加就会报错。\nvar a=3\n(function(){alert(123)})()\n或\nvar a=3\n[1,2]forE....")])])]),n._v(" "),e("h3",{attrs:{id:"高级部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高级部分"}},[n._v("#")]),n._v(" 高级部分")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("原型对象")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("再认识\n函数的原型对象默认指向一个空对象，里面默认有下面这两个属性。\n            constructor //指向自己this\n            "),e("strong",[n._v("proto")]),n._v(" //原型的原型对象")])]),n._v(" "),e("li",[e("p",[n._v("显式原型与隐式原型\n显式原型对象与隐式原型对象\n函数prototype 显式原型对象====对应实例的 "),e("strong",[n._v("proto")]),n._v(" 隐式原型对象\n          创建函数时，Fn.prototype={}\n          创建实例时，this."),e("strong",[n._v("proto")]),n._v("=Fn.prototype")])]),n._v(" "),e("li",[e("p",[n._v("原型链")])]),n._v(" "),e("li",[e("p",[n._v("原型链的继承")])])])]),n._v(" "),e("li",[e("p",[n._v("变量提升与函数提升\n*变量提升与函数提升\n变量提升，执行之前先声明，但未赋值\n函数提升，在语句之前已声明，完整存在")]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    理解：在变量执行之前，就可以访问到了，但它的值是undefined。在函数执行之前，就可以调用到了。因为存到了上下文中栈中了。\n    且先执行变量提升再执行函数提升！！\n    注意：就算是if语句中的变量，也是会自动进行变量提升的。\n")])])])]),n._v(" "),e("li",[e("p",[n._v("作用域\n*作用域 ——迷惑型题目\n题1：\nvar a=4;\nfunction fun1(){\nconsole.log(a);\n}\nfunction fun2(){\nvar a=6;\nfun1();\n}\nfun2();\n结果： 4 ，是根据自己身所在位置进行查找的，而不是根据关系查找。\n题2\nvar obj={\ntet:function (){\nconsole.log(tet);\n}\n}\nobj.tet();\n结果是：报错，找不到\n总结：是根据上下文栈块逐层查找的。")])]),n._v(" "),e("li",[e("p",[n._v("执行上下文")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("分类\nJavaScript 中有三种执行上下文类型。\n全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。\n函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。\nEval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。")])]),n._v(" "),e("li",[e("p",[n._v("执行上下文栈")]),n._v(" "),e("ul",[e("li",[n._v("执行上下文栈.jpg")])])])])]),n._v(" "),e("li",[e("p",[n._v("闭包")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("产生的条件\n函数内嵌套有函数，\n内函数引用了外函数的属性（变量或函数),\n并且外部函数被调用执行;\n(function Pro(){\nvar a=Math.random();\nwindow.mm=function (x,y){\nreturn Math.floor(y-a*(y-x));\n}\n})()//外部函数调用")])]),n._v(" "),e("li",[e("p",[n._v("自定义JS模块\njs自定义模块\n将代码封装在一个JS文件中，有特定功能。向外暴露一些行为函数。\n1、私有数据\n2、操作数据的函数\n3、向外暴露对象（给外部使用的方法）\nvar myModule = (function(){\nvar var1 = 1;\nvar var2 = 2;\nfunction func1(){\n...\n}\nfunction func2(){\n...\n}\nreturn {\nfunc1: func1,\nfunc2: func2\n};\n})();")])]),n._v(" "),e("li",[e("p",[n._v("终极面试题\n终极面试题\nfunction fun(n,o){\nconsole.log(o);\nreturn {\nfun:function (m) {\nreturn fun(m, n);\n}\n}\n}\nvar a=fun(0).fun(1).fun(2).fun(3);\n解析：a=fun(0) 时，它的返回值中含有闭光，值为0\n...fun(1) 时，它的返回值中含有闭光，值为1\n.....f")])])])]),n._v(" "),e("li",[e("p",[n._v("内存的溢出与泄露\n*内存溢出与内存泄露\n你需要的内存大于剩余的内存空间，就会导致内存溢出。从而报错。\n内存泄露：不合理地占用内存资源，而不及时地释放\n，如，定时器、函数中变量的错误声明为全局变量等，都会导致内存泄露从而使内存溢出。")])]),n._v(" "),e("li",[e("p",[n._v("借用构造函数\n构造函数借用构造函数：得到属性\nfunction Fun1(age){\nthis.age=age;\n}\nfunction Fun2(name,age){\nthis.name=name;\nFun1.call(this,age);//开始借用\n}")])]),n._v(" "),e("li",[e("p",[n._v("单线程与多线程")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n*单线程与多线程\n有的程序是单进程有的是多进程的，而多进程数据一般是不共享的，且每一个进程可能有多个线程。\nJS是单线程的：警告框可以暂停主线程的执行，如果是多线程会带来很复杂的同步问题。")])]),n._v(" "),e("li",[e("p",[n._v('Web worker多线程技术\n*Web Worker\nWeb Worker，作为JS中的多线程技术，主要用来处理耗时较长的程序。\n主线程（老板）---调用*.js文件\nvar wo=new Worker("fine.js");\nwo.postMessage(1);//向分线程发送数据\nwo.onmessage=function (e){\n//接收分线程传过来的数据\nconsole.log(e.data);\n}\n分线程（工人）---* .js\nvar onmessage=function(event){\nvar jout=++(event.data); //接收主线程传过来的数据\npostMessage(jout );//向主线程发送数据\n}')])])])]),n._v(" "),e("li",[e("p",[n._v("回调队列")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("认识\n回调队列\n \t初始化代码执行完后，才会执行回调代码，而执行回调代码时先将它们添加到对应的模块中，当条件满足时，如点击了，定时器的时间到了，就会将其添加到回调队列后面进行排队,然后先进先出。\n*Web Worker")]),n._v(" "),e("div",{staticClass:"language-纯文本 extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('  var yfd=document.getElementById("yfd");\n  yfd.onclick=function (){//点击后，会在后面添加到回调队列中。\n    console.log("点击事件:进入回调队列并执行了~");\n  }\n  setTimeout(function (){\n    console.log("外部定时器已开始");\n    setTimeout(function (){console.log("内部定时器结束了")},3000);//会添加对应模块中，3秒条件满足后，会在后面添加到回调队列中。\n    console.log("外部定时器已结束,此时如果你不点击回调队列中没有东西。但已新添加了一个定时器，等下不管你有没有点击，3秒后都会添加到事件队列中");\n  },20);\n  console.log("初始化执行完了。。");\n')])])])]),n._v(" "),e("li",[e("p",[n._v("图解")])])])])]),n._v(" "),e("p",[e("em",[n._v("XMind: ZEN - Trial Version")])])])}),[],!1,null,null,null);e.default=o.exports}}]);